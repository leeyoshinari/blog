<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>白瑜的博客</title>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="shortcut icon" href="/img/favicon.ico">
  <script src="/js/jquery.min.js"></script>
  <link rel="stylesheet" href="/css/viewer.min.css">
  <script src="/js/viewer.min.js"></script>
</head>
<body>
  <div class="l_body s:aa content tech" id="start" layout="post" >
    <aside class="l_left"></aside>
    <div class="l_main" id="main">
      <header class="header mobile-only"></header>
      <div class="article banner top"><div class="content"><div class="bottom only-title"><div class="text-area">
        <h1 class="text title"><span>Linux 性能分析实战</span></h1>
      </div><div class="publish-date"><span>发布时间：2024-08-03</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>更新时间：2024-08-03</span></div></div></div></div>
      <article class="md-text content">
        <h2>介绍</h2>
        <p>性能分析，其实就是找出应用或系统的瓶颈，并设法去避免或者缓解它们，从而更高效地利用系统资源处理更多的请求，这包括以下几个步骤：</p>
        <p class="non-row md-indent">1、为应用程序和系统设置性能目标</p>
        <p class="non-row md-indent">2、进行性能基准测试</p>
        <p class="non-row md-indent">3、性能分析和定位</p>
        <p class="non-row md-indent">4、优化系统和应用程序</p>
        <p class="non-row md-indent">5、性能监控和告警</p>
        <p><span style="font-weight: bold;">工欲善其事，必先利其器</span>。性能领域大师 Brendan Gregg 描绘的性能工具图谱：</p>
        <img src="/img/note/perf/tools.png" alt="tools.png" loading="lazy" />
        <h2>CPU 性能</h2>
        <h3>平均负载</h3>
        <p>平均负载可通过执行 top 或 uptime 命令查看，<code>load average</code> 后面的 3 个数字依次是系统过去 1 分钟、5 分钟、15分钟的平均负载。</p>
        <h4>怎么理解平均负载</h4>
        <p>平均负载是指单位时间内，系统处于<span style="font-weight: bold;">可运行状态</span>和<span style="font-weight: bold;">不可中断状态</span>的平均进程数，也就是<span style="font-weight: bold;">平均活跃进程数</span>。所谓可运行状态的进程是指处于 R 状态（Running 或 Runnable）的进程；不可中断状态的进程是指处于 D 状态的进程。</p>
        <p>如果平均负载为 2，那意味着：</p>
        <p class="non-row md-indent">· 在 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用</p>
        <p class="non-row md-indent">· 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的是空闲的</p>
        <p class="non-row md-indent">· 在 1 个 CPU 的系统上，意味着有一半的进程竞争不到 CPU</p>
        <h4>平均负载多少合理</h4>
        <p>如果在 1 个 CPU 的系统上，通过命令查看平均负载的 3 个数值是 1.88, 0.88, 5.88，那就说明在过去 1 分钟内，系统有 88% 的超载，而在过去的 15 分钟内，系统有 488% 的超载，从整体趋势来看，系统的负载是在降低的。</p>
        <p>一般来说，当<span style="font-weight: bold;">平均负载超过 CPU 数量的 70% </span>时，就需要排查负载高的原因了。70% 不是绝对的，推荐做法是把平均负载监控起来，根据历史数据来判断负载变化趋势，如果负载明显升高，则需要去排查问题。</p>
        <h4>平均负载和CPU使用率</h4>
        <p>平均负载和 CPU 使用率变化并不完全一致：</p>
        <p class="non-row md-indent">· CPU 密集型进程，大量使用 CPU 会导致平均负载升高，此时两者变化是一致的</p>
        <p class="non-row md-indent">· IO 密集型进程，等待 IO 也会导致平均负载升高，但 CPU 使用率不一定高</p>
        <p class="non-row md-indent">· 大量等待 CPU 的进程调度也会导致平均负载升高，此时 CPU 使用率也会变高</p>
        <h3>CPU上下文切换</h3>
        <p>进程在竞争 CPU 时并没有真正的运行，为什么还会导致系统负载升高？可能的原因之一是CPU 上下文切换，根据一些测试报告，CPU 进行一次上下文切换需要消耗几十纳秒到几微秒的 CPU 时间，如果上下文切换比较多的情况下，CPU 将会花费大量时间用于切换上下文，缩短了真正运行进程的时间，这是导致负载升高的一个重要因素。</p>
        <p>CPU 在进行上下文切换时，CPU 的主要工作是保存当前任务的 CPU 寄存器和程序计数器，然后加载下一个任务的 CPU 寄存器和程序计数器。根据不同的场景，CPU 上下文切换可分为进程上下文切换、线程上下文切换和中断上下文切换。</p>
        <h4>查询CPU上下文切换</h4>
        <p>使用 vmstat 命令查看 CPU 上下文切换和中断的数据</p>
        <pre style="margin-left: 2em;"><code># 每秒输出一组数据<br>$ vmstat 1<br>procs --memory-- -swap- --io-- -system-- --cpu--<br>r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st<br>0  0 132448  95884  82524 355236    0    0     1     3   24    4  1  0 99  0  0</code></pre>
        <p class="non-row md-indent">r（Running or Runnable）是就绪队列的长度。如果该值大于 CPU 核数，则有进程在竞争 CPU。</p>
        <p class="non-row md-indent">b（Blocked）是处于不可中断状态的进程数</p>
        <p class="non-row md-indent">cs（context switch）是每秒上下文切换次数</p>
        <p class="non-row md-indent">in（interrupt）是每秒中断的次数</p>
        <p>查看进程的上下文切换数据</p>
        <pre style="margin-left: 2em;"><code>$ pidstat -w -u 1<br>Linux 4.18.0-348.7.1.el8_5.x86_64 (centos)      08/03/2024      _x86_64_        (2 CPU)<br><br>06:12:00 PM   UID    PID   cswch/s nvcswch/s  Command<br>06:12:01 PM     0        11     36.27      0.00  rcu_sched<br>06:12:01 PM     0     24952     10.78      0.00  redis-server<br>06:12:01 PM     0     32128      0.98      0.00  kworker/0:1-events</code></pre>
        <p>cswch 是自愿上下文切换，是指进程因无法获取所需资源而导致的上下文切换。nvcswch 是非自愿上下文切换，是指进程由于 CPU 时间片到了等原因，被系统强制调度而发生的上下文切换。</p>
        <p>如果查看进程的上下文切换，发现上下文切换数量不高，那么可以查看线程的上下文切换，使用命令是</p>
        <pre style="margin-left: 2em;"><code>pidstat -wt 1</code></pre>
        <p>查看发生了什么类型的中断，</p>
        <pre style="margin-left: 2em;"><code>watch -d cat /proc/interrupts</code></pre>
        <h4>上下文切换问题分析</h4>
        <p>每秒上下文切换的次数和 CPU 的性能有关，一般情况下，上下文切换次数超过一万次，或者切换次数出现数量级增长，系统很可能已经出现了性能问题。</p>
        <p class="non-row md-indent">· 自愿上下文切换多，说明进程都在等待资源，可能发生了 IO 问题；</p>
        <p class="non-row md-indent">· 非自愿上下文切换多，说明进程都在被强制调度，也就是进程都在争抢 CPU，CPU 成了瓶颈；</p>
        <p class="non-row md-indent">· 中断次数多了，说明 CPU 主要在处理中断，通过查看 <code>/proc/interrupts</code> 分析具体的中断类型；</p>
        <h3>CPU使用率</h3>
        <p>我们常看到的 CPU 使用率是平均 CPU 使用率，是一些工具或命令每隔一段时间获取一次数据，作差后计算出这段时间的平均 CPU 使用率。计算公式：</p>
        <pre style="margin-left: 2em;"><code>平均CPU使用率 = 1 - (Δ空闲时间 / Δ总CPU时间)</code></pre>
        <p>常用的查询 CPU 使用率的工具：</p>
        <p class="non-row md-indent">mpstat：CPU 性能分析工具，实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。</p>
        <p class="non-row md-indent">pidstat：进程性能分析工具，实时查看进程的 CPU、内存、IO、上下文切换等性能指标。</p>
        <h4>应用CPU使用率过高</h4>
        <p>通过 top、ps、pidstat 等工具很容易找到 CPU 使用率高的进程和线程。对于 Java 应用，我们一般通过以下步骤定位问题：</p>
        <p class="non-row md-indent">1、通过 <code>top</code> 命令找到进程 PID，通过 <code>top -Hp PID</code> 命令查看该进程下的线程，找到占用 CPU 的线程 PID；</p>
        <p class="non-row md-indent">2、将线程 PID 转成 16 进制，<code>printf '%x\n' 线程 PID</code></p>
        <p class="non-row md-indent">3、分析问题，<code>jstack 进程PID | grep 线程16进制 -A 30</code></p>
        <p class="non-row md-indent">4、通过堆栈中的信息，可以直接定位到代码中的出现问题的具体位置</p>
        <p>但如果不是 Java 应用呢？下面是一种通用的方法——使用 perf 工具可以分析 CPU 性能：</p>
        <pre style="margin-left: 2em;"><code>$ perf top<br>Samples: 8K of event 'cycles', 3000 Hz, Event count (approx.): 728643798 lost: 0/0 drop: 0/0<br>Overhead  Shared Object                              Symbol<br>   2.07%  [kernel]                                   [k] find_get_entry<br>   1.50%  libpython3.11.so.1.0                       [.] _PyEval_EvalFrameDefault<br>   0.96%  perf                                       [.] dso__find_symbol<br>   0.86%  [kernel]                                   [k] __sched_text_star</code></pre>
        <p>第一行数据是 perf 共采集了 8K 个 CPU 周期，总事件数为 728643798。列表中一共 4 列，分别是：</p>
        <p class="non-row md-indent">· Overhead：该 Symbol 事件在所有采样中的比例</p>
        <p class="non-row md-indent">· Shared：该函数或者指令所在的动态共享对象，如内核、进程名、动态链接库名、内核模块名 等</p>
        <p class="non-row md-indent">· Object：动态共享对象的类型，[.] 表示用户空间的可执行程序或者动态链接库，[k] 表示内核空间</p>
        <p class="non-row md-indent">· Symbol：函数名，当函数名未知时，用 16 进制的地址来表示</p>
        <p>如果需要显示函数调用关系，那么需要执行这个命令 <code>perf top -g -p pid</code>，然后按方向键选择查看对应函数的调用关系。例如：执行如下 python 代码：</p>
        <pre style="margin-left: 2em;"><code>result = 1<br>while True:<br>    result *= 11</code></pre>
        <p>通过 <code>perf top -g -p pid</code> 命令查看的结果如下图，mul 函数的 CPU 使用率最高，和代码里存在的问题是一样的。</p>
        <img src="/img/note/perf/perf_mul.jpg" alt="perf_mul.jpg" loading="lazy" />
        <p><span style="font-weight: bold;">若出现无法解释的 CPU 使用率高的情况</span>，那么可以考虑是否存在短时应用，一般有如下 2 中情况：</p>
        <p class="non-row md-indent">1、应用里直接调用了其他二进制程序，这些程序运行时间短，很难通过 top 命令发现；</p>
        <p class="non-row md-indent">2、应用本身在不停的崩溃重启，启动过程的资源初始化，可能会占用较多的 CPU；</p>
        <p>对于这类进程，可以使用 <code>pstree</code> 或者 <code>execsnoop</code> 找到它们的父进程，从父进程入手排查问题。</p>
        <h3>iowait</h3>
        <p>iowait 高不一定代表 IO 有性能瓶颈。一般提到 iowait 升高，首先会想到是磁盘IO，可通过命令 <code>iostat -x -m 1 2</code> 查询服务器所有磁盘的 IO 情况。如果发现磁盘 IO 很高，那么就需要使用 <code>top</code> 命令查看哪些进程处于 D 状态，然后用 <code>pidstat -d -p pid 1 3</code> 命令查看进程的 IO 数据。</p>
        <p>一般情况到这里已经可以发现问题了，如果想知道应用到底在执行什么 IO 操作，那就需要查看系统的进程调用，可使用 <code>strace -p pid</code> 命令。</p>
        <p>如果上面步骤还找不出来问题，那么进程可能已经是僵尸进程了，可通过 <code>top</code> 或者 <code>ps aux |grep pid</code> 命令查看进程的状态。如果出现僵尸进程，需要找到父进程，可通过 <code>pstree -aps pid</code>命令查找，然后在代码里查找子进程结束的处理是否正确。</p>
        <p>如果还是找不出来问题，那么就需要基于事件记录的动态追踪工具了，还是使用 <code>perf top</code> 命令了。</p>
        <h3>中断</h3>
        <h4>中断是什么</h4>
        <p>Linux 为了解决中断处理程序执行过长和中断丢失问题，将中断处理过程分为两个阶段，分别是上半部和下半部</p>
        <p class="non-row md-indent">· 上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作，就是常说的硬中断。</p>
        <p class="non-row md-indent">· 下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行，就是常说的软中断。</p>
        <p>以网卡接收数据包为例：网卡接收到数据包后，会通过硬件中断的方式通知内核新的数据到了，上半部和下半部分别负责的工作是：</p>
        <p class="non-row md-indent">· 上半部就是把网卡的数据读到内存，然后更新硬件寄存器的状态（表示数据已读完），最后发送一个软中断的信号，通知下半部做进一步处理。</p>
        <p class="non-row md-indent">· 下半部被软中断信号唤醒，从内存中读取数据，然后按照网络协议栈，对数据进行逐层解析和处理，直到把数据送到应用程序。</p>
        <h4>查看中断</h4>
        <p>查看软中断的运行情况<code>cat /proc/softirqs</code>，查看硬中断的运行情况<code>cat /proc/interrupts</code>。查看软中断的输出结果，可以看到各种类型的软中断在不同 CPU 上的累积运行次数：</p>
        <pre style="margin-left: 2em;"><code>$ cat /proc/softirqs<br>          CPU0       CPU1<br>HI:          0          0<br>TIMER:   16123954   15249385<br>NET_TX:          1          0<br>NET_RX:    4197945    2727293<br>BLOCK:     174780     162562<br>IRQ_POLL:          0          0<br>TASKLET:      55285      76987<br>SCHED:   24546262   22247964<br>HRTIMER:       3055       1435<br>RCU:   21638913   20773231</code></pre>
        <p>第一列是软中断类型。正常情况下，同一种类型的软中断在不同的 CPU 上分布是差不多的，除了 TASKLET 软中断，每个 TASKLET 只运行一次就结束，并且只在调用它的函数所在的 CPU 上运行。</p>
        <p>软中断是以内核线程的方式运行的，可通过 <code>ps aux|grep softirq</code> 命令查看这些线程运行情况。</p>
        <h2>总结</h2>
        <img src="/img/note//perf/summary.jpg" alt="summary.jpg" loading="lazy" />
        <hr style="margin-top: 3em;">
        <div class="article-footer fs14"></div>
      </article>
      <footer class="page-footer footnote"><hr></footer>
      <div class="main-mask" onclick="sidebar.dismiss()"></div>
    </div>
    <aside class="l_right"></aside>
  </div>
</body>
<script type="module">
  import { createLeft, createFootNote, createMobileHeader, createDonate, createRight, createFloatPanel } from '/js/template.js';
  document.getElementsByClassName('l_left')[0].appendChild(createLeft());
  document.getElementsByClassName('header mobile-only')[0].appendChild(createMobileHeader());
  document.getElementsByClassName('article-footer fs14')[0].appendChild(createDonate());
  document.getElementsByClassName('page-footer footnote')[0].appendChild(createFootNote());
  document.getElementsByClassName('l_right')[0].appendChild(createRight());
  document.getElementById('start').appendChild(createFloatPanel());
</script>
<script type="text/javascript" src="/js/main.js"></script>
</html>
